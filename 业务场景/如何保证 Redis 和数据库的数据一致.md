## 如何保证 Redis 和数据库的数据一致

#### 缓存更新策略：Cache Aside Pattern（旁路缓存模式）

##### 场景：

Redis 作为缓存层用于提升系统的读取性能，MySQL 作为持久层存储，用户保证数据可靠性。

- 系统先查询 Redis 缓存，如果缓存中没有数据，再从 MySQL 查询并将数据写入 Redis 缓存。
- 更新数据时，更新 MySQL 并删除 Redis 缓存，使缓存失效，保证下去读取数据时能拿到最新数据。

##### 业务场景：

获取商品详情页。

##### 问题：

并发请求较高时，可能 A 线程更新数据时，B 线程在缓存失效的瞬间读取了旧数据，再次缓存到 Redis，导致数据不一致。

##### 解决方法：

延迟双删策略。

- 删除 Redis 数据
- 更新 MySQL
- 适当延迟（如500ms），再次删除 Redis 数据

**适合查询较多的数据。**

#### 先更新缓存再更新数据库

##### 场景：

实时性要求较高的场景中，可以考虑先更新 Redis 缓存，再异步更新 MySQL 数据库（如使用消息队列）。

##### 业务场景：

秒杀系统商品库存的扣减，用户购买商品时，先更新 Redis 中的库存数量，保证极低延迟的实时性体验。然后再将变更异步写入 MySQL，确保持久化存储一致性。

##### 问题：

- 幂等性保障：确保消息的处理是幂等的，相同的消息即使被处理多次，也不会导致库存重复扣减。
- 消息重试机制：如果消费消息时更新 MySQL 失效，可以设置重试机制或消息补偿机制，保证最终数据一致性。

**适合更新频繁，对性能要求较高的数据。**

#### 双写操作（缓存与数据库同时更新）

##### 场景：

业务需要 Redis 与 MySQL 的数据同时更新，如用户余额更新、积分奖励系统等场景。

##### 问题：

- 同步性问题：由于需要保证 Redis 和 MySQL 同时更新数据，必须考虑事务性问题。
- 分布式事务：如果是分布式架构，可能需要使用 TCC（Try、Confirm、Cancel）等模式

**适合更新频繁，比较重要的数据。**

#### 数据回写（Write Back）策略

##### 场景：

回写模式适用于 Redis 作为缓存层，MySQL 作为持久层，但 Redis 中数据修改后并不立即同步更新 MySQL，而是在特定实际触发数据回写。

##### 业务场景：

广告计费系统：广告点击量保存在 Redis 中，减少频繁的数据库写入压力，定期将 Redis 中的统计数据批量写入 MySQL。

- 定量回写：数据量达到 5 万时，回写数据库
- 定时回写：每天回写一次数据库

##### 问题：

需要防止 Redis 崩溃造成的数据丢失，Redis 数据需要增加持久化支持。

**适合更新频繁，不是很重要的数据。**