## 订单超时取消的实现思路

在系统中，有非常多的功能需要用到定时执行，比如订单超时取消，优惠券失效等。

#### JDK 自带的延迟队列

使用 `DelayQueue`，自定义重写方法，根据需要排序。

创建订单时，将订单数据插入到 `DelayQueue` 中，以超时时间作为排序条件。

用一个线程不停轮询队列的头部，如果订单超时，就出队进行超时处理，更新订单状态到数据库。

 由于 `DelayQueue` 是内存中数据，每次重启服务器时，需要从数据库中加载未到期的顶顶那，初始化队列。

##### 优点：

简单，不需要第三方组件。

##### 缺点：

所有超时订单都加入到 DelayQueue 中，占用内存大。

没法做到分布式处理，效率低。

不适合订单量大的场景。

#### 使用消息队列

创建订单时，在消息生产者端，发送延迟消息。到期后消息被发送到消费者端，消费者处理订单超时，更新订单状态。

##### 优点：

使用简单，支持分布式，精度高。

##### 缺点：

成本高，每个订单都需要新增定时消息，且不会马上消费。

#### 使用 Redis 过期监听

订单创建后，在订单中存入订单的 key，并且实现一个 Redis 过期时间监听，当过期时间到了，对订单数据进行处理。

##### 优点：

实现简单，支持分布式。

##### 缺点：

不可靠。如果Redis过期，应用正好重启，会导致通知事件丢失，大量订单一直无法关闭。

订单量大时，占用大量存储空间。

#### 定时任务

使用 `quartz`、`xxljob` 等实现任务调度。

设置一个时间间隔，定期筛选过期的订单数据进行批处理。

##### 优点：

简单，成本低，对服务器压力小。

##### 缺点：

不精准。如果定时周期设置太短，执行的频率太高，对数据库QPS太高会造成数据库压力。如果周期设置太长，过期时间则会不准确。

可以单独分出来一个超时库，减轻订单数据库的压力。